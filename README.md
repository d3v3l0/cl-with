# WITH-

WITH- is a Swiss-army-knife macro that attempts to make CL code more consice and regular - by grouping all `with-` macros and providing uniform syntax for creating and accessing structs, class instances, and CFFI objects.

The most visible benefit: grouping any number of existing with- macros together avoids deep indentation and makes complicated expressions simpler:
```
(with-
    (:open-file ( ...))    
	...
    (:output-to-string .))
  ...))
```
More importantly, WITH- unifies the syntax for dealing with structs, classes, and foreign CFFI objects, extracting and rebinding slot accessors (automatically or selectively).
```
(with- (:temp :int p)                                ; like with-foreign-object
       (:temp (:struct gtk:g-point) gpt "P1-")       ; prefixed: p1-x and p1-y 
       (:old 'q:spoint spt "P2-")                    ; existing instance, p2-x etc.
       (:new 'graphics:point ppp "" (h hor)(v ver))  ; rename graphics::hor to h, etc.
  (setf p1-x p2-x              ;note that bindings are package-local!
        p1-y p2-y)             ;and prefixed to differentiate multiple objects
  (setf h (+ p1-x p2-x)
        v (- p1-x 3))
  ppp) 
```  
  
* works with structs and classes, as well as foreign objects;
* automatically figures out and binds all slots by default;
* automatically rebinds package-local names regardless of where objects are defined;
* allows multiple instances to be processed;
* allows per-instance prefix to differentiate names;
* works with existing :old objects
* allocates :new objects when requested
* allocates :temp objects, destroying CFFI objects at the end


## License

BSD 3-clause License

## Installation

Clone the repo into a visible directory, use (ql:quickload "CL-WITH") or ASDF magic.

This library requires CFFI and CLOSER-MOP

## Usage

`(with- descriptor body)` or `(with- (descriptor1 ...) body)` 

Each descriptor is a list.  It may start with a shortened version of any existing with- macro, with the 'with-' prefix removed (and package specified, if required).  WITH-OPEN-FILE must be written as  `(with- (open-file ...)`  In this case, the rest of the list contains whatever the original macro expects.

(TODO:) `:let` and `:multiple-values` and `:destructure` 


A descriptor may also be in the form of:

`(:new|:temp|:old type instance [prefix] [bindings]`

```
disposition  :new  to create a new object and bind to 'instance'
             :temp as above, but destroyed on exit if foreign
			 :old  to use an existing, bound 'instance'
			 
type         A quoted symbol signifying struct or class name
             A symbol whose symbol-value is an actual <TYPE-CLASS>
			 A keyword denoting a simple CFFI type such as :int
			 A list representing a cffi type such as (:STRUCT ...)
			 
instance     A symbol, bound to an existing object if :old, or to be
              bound to a newly created object if :new or :temp

prefix       A string to be appended to all slot accessors for this instance
             Optional; default is ""

bindings     A list of bindings in the format acceptable to 'with-slots' or 
             'with-foreign-slots', as appropriate.  Optional; defaults to
			 automatic extraction and rebinding of all slots
```

## Observations and notes:

The code generated by with clauses is nested in the same sequence as it's written, and any symbols bound in a clause are available to all inner clauses as well as the body.

			 


			 

			 
			 
